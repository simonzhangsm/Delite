package engine;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.Reductions;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.utils.Bits;

class DelayLib extends KernelLib {

  DFEVar en;
  DFEVector<DFEVar> d;
  DFEVar rst_en;
  Bits rstVal;
  int bits;
  DFEVector<DFEVar> q;

  int muxSize;
  int muxInt;
  DFEVar[] dVec;
  DFEVar[] enVec;

  void common(DFEVar en, DFEVector<DFEVar> d, DFEVar rst_en, Bits rstVal, int muxSize) {
    this.bits = d[0].getType().getTotalBits();
    this.muxSize = muxSize;
    this.rstVal = rstVal;
    this.rst_en = rst_en;
    this.muxInt = 0;

    if (muxSize == 1) {
      this.d = d;
      this.en = en;
    } else {
      DFEVector<DFEVar> sel = new DFEVectorType<DFEVar>(dfeBool(), muxSize).newInstance(this); 
      this.dVec = new DFEVar[muxSize];
      this.enVec = new DFEVar[muxSize];
      for (int i = 0; i < muxSize; i++) {
        this.dVec[i] = d[0].getType().newInstance(this);
        this.enVec[i] = dfeBool().newInstance(this);
        sel[i] <== this.enVec[i];
      }
      // Kindly finish MUX-ing in one cycle
      optimization.pushPipeliningFactor(0);
      this.d = new DFEVectorType<DFEVar>(d[0].getType(), d.getSize()).newInstance(this, control.oneHotMux(sel.pack(), this.dVec));
      this.en = control.oneHotMux(sel.pack(), this.enVec);
      optimization.popPipeliningFactor();
    }

    q = Reductions.streamHold(this.d, this.en, rst_en, rstVal);

  }

  public DelayLib(KernelLib owner, DFEVar en, DFEVar d, DFEVar rst_en, Bits rstVal) {
    super(owner);

    DFEVector<DFEVar> d_vector = new DFEVectorType<DFEVar>(d.getType(), 1).newInstance(this, d);
    common(en, d_vector, rst_en, rstVal, 1);
  }

  public DelayLib(KernelLib owner, DFEVar en, DFEVector<DFEVar> d, DFEVar rst_en, Bits rstVal) {
    super(owner);
    common(en, d, rst_en, rstVal, 1);
  }

  public DelayLib(KernelLib owner, DFEType t) {
    super(owner);
    common(
      dfeBool().newInstance(this),
      new DFEVectorType<DFEVar>(t, 1).newInstance(this),
      dfeBool().newInstance(this),
      Bits.allZeros(t.getTotalBits()), 1
    );
  }

  public DelayLib(KernelLib owner, int bits, long rstVal) {
    super(owner);
    common(
      dfeBool().newInstance(this),
      new DFEVectorType<DFEVar>(dfeRawBits(bits), 1).newInstance(this),
      dfeBool().newInstance(this),
      new Bits(bits, rstVal), 1
      );
  }
  public DelayLib(KernelLib owner, int bits, long rstVal, int muxSize) {
    super(owner);
    common(
      dfeBool().newInstance(this),
      new DFEVectorType<DFEVar>(dfeRawBits(bits), 1).newInstance(this),
      dfeBool().newInstance(this),
      new Bits(bits, rstVal), muxSize
      );
  }

  public DelayLib(KernelLib owner, DFEType t, Bits rstVal) {
    super(owner);
    common(
      dfeBool().newInstance(this),
      new DFEVectorType<DFEVar>(t, 1).newInstance(this),
      dfeBool().newInstance(this),
      rstVal, 1
    );
  }

  void write(DFEVar data) {
    if (this.muxSize == 1) {
      d <== d.getType().newInstance(this, data);
      en <== constant.var(true);      
    } else {
      this.dVec[muxInt] <== data;
      this.enVec[muxInt] <== constant.var(true);
      muxInt++;
    }

  }

  void write(DFEVar data, DFEVar wen) {
    if (this.muxSize == 1) {
      d <== d.getType().newInstance(this, data);
      en <== wen;
    } else {
      this.dVec[muxInt] <== data;
      this.enVec[muxInt] <== wen;
      muxInt++;
    }
    
  }

  void write(DFEVar data, DFEVar wen, DFEVar rst) {
    if (this.muxInt == 0) {
      rst_en <== rst; // TODO: Figure out how to | the reset signals togetha      
    }
    if (this.muxSize == 1) {
      d <== d.getType().newInstance(this, data);
      en <== wen;
    } else {
      this.dVec[muxInt] <== data;
      this.enVec[muxInt] <== wen;
      muxInt++;
    }
  }

  void write(DFEVar data, DFEVar wen, DFEVar rst, int p) {
    write(data,wen,rst);
  }

  void write(DFEVector<DFEVar> data) {
    if (this.muxSize == 1) {
      d <== data;
      en <== constant.var(true);
    } else {
      System.out.printf("ERROR: Not sure how to handle vector-write on a muxed-input reg");
      System.exit(-1);
    }
  }

  void write(DFEVector<DFEVar> data, DFEVar wen) {
    if (this.muxSize == 1) {
      d <== data; 
      en <== wen;
    } else {
      System.out.printf("ERROR: Not sure how to handle vector-write on a muxed-input reg");
      System.exit(-1);
    }
  }

  void write(DFEVector<DFEVar> data, DFEVar wen, DFEVar rst) {
    if (this.muxSize == 1) {
      d <== data; 
      en <== wen;
    } else {
      System.out.printf("ERROR: Not sure how to handle vector-write on a muxed-input reg");
      System.exit(-1);
    }
    rst_en <== rst;
  }


  DFEVar read() {
    return q[0];
  }

  DFEVector<DFEVar> readv() {
    return q;
  }
}
